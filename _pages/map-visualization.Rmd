---
layout: archive
permalink: /map-visualization/
title: "Map Visualization"
author_profile: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message = FALSE}
# Load libraries
library(ggplot2)
library(leaflet)
library(RColorBrewer)
library(dplyr)
library(readr)
```

```{r, message = FALSE}
# Load datasets
building_fires <- read_csv('building_fires.csv')
FDNY_fh_listing <- read_csv('FDNY_Firehouse_Listing.csv')
FDNY_fh_listing <- FDNY_fh_listing %>% filter(!is.na(Latitude), !is.na(Longitude))
```



### __1. Location of Severe Fires__

Provide a `leaflet` map of the highest severity fires (i.e. subset to the highest category in `HIGHEST_LEVEL_DESC`) contained in the file `buiding_fires.csv`. Ignore locations that fall outside the five boroughs of New York City. Provide **at least three pieces of information on the incident in a popup**.

```{r}
# Subset data to the highest severity fire (5th alarm)
q1_data <- building_fires %>%
  filter(HIGHEST_LEVEL_DESC == '5 - 5th alarm' |
           HIGHEST_LEVEL_DESC == '55 - Fifth Alarm')
```


```{r}
# Create leaflet map object
q1_m <- leaflet(q1_data) %>%
  addTiles('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png')

# Create popup details
content <- paste("Fire Started: ", q1_data$INCIDENT_DATE_TIME, "<br/>",
                 "Fire Extinguished: ", q1_data$LAST_UNIT_CLEARED_DATE_TIME, "<br/>",
                 "Units on scene: ", q1_data$UNITS_ONSCENE,"<br/>")
# Add colors
pal = colorFactor("Set2", domain = q1_data$DETECTOR_PRESENCE_DESC)
color_detector = pal(q1_data$DETECTOR_PRESENCE_DESC)

# Create the final one with marker, with content information available
q1_final <- q1_m %>%
    setView(-74, 40.755, zoom = 12) %>%
  addCircles(color = color_detector, popup = content) %>%
  addLegend(pal = pal, values = ~q1_data$DETECTOR_PRESENCE_DESC, title = "Detectors") %>%
  clearBounds()

q1_final

```




### __2. Layers and Clusters__

__a) Color by Type of Property__
Start with the previous map. Now, distinguish the markers of the fire locations by `PROPERTY_USE_DESC`, i.e. what kind of property was affected. If there are too many categories, collapse some categories. Choose an appropriate coloring scheme to map the locations by type of affected property. Add a legend informing the user about the color scheme. Also make sure that the information about the type of affected property is now contained in the popup information. Show this map.

```{r}
# Data manipulation
q1_data <- q1_data %>%
  mutate(PROPERTY_USE = ifelse(PROPERTY_USE_DESC == "429 - Multifamily dwelling"| PROPERTY_USE_DESC == "419 - 1 or 2 family dwelling", "Family Housing",
                               ifelse(PROPERTY_USE_DESC == "131 - Church, mosque, synagogue, temple, chapel",
                                      "Places of Worship",
                                      ifelse(PROPERTY_USE_DESC == "161 - Restaurant or cafeteria", "Restaurants",
                                             ifelse(PROPERTY_USE_DESC =="500 - Mercantile, business, other" | PROPERTY_USE_DESC == "599 - Business office" | PROPERTY_USE_DESC == "891 - Warehouse", "Business, Offices, Warehouses",
                                                    ifelse(PROPERTY_USE_DESC == "519 - Food and beverage sales, grocery store", "Grocery Stores", "Other"))))))


```


```{r}
# Add color detail based on property use
pal = colorFactor("Set2", domain = q1_data$PROPERTY_USE)
color_property = pal(q1_data$PROPERTY_USE)


# Add the property use description in popup details
content2 <- paste("Fire Started: ", q1_data$INCIDENT_DATE_TIME, "<br/>",
                 "Fire Extinguished: ", q1_data$LAST_UNIT_CLEARED_DATE_TIME, "<br/>",
                 "Building Type: ", q1_data$PROPERTY_USE,"<br/>", #added
                 "Units on scene: ", q1_data$UNITS_ONSCENE,"<br/>")

# Create the final one with marker, with content information available
q2_a <- q1_m %>% addCircles(lat = ~lat, lng = ~lon, color = color_property) %>%
    setView(-74, 40.755, zoom = 12) %>%
  addCircleMarkers(color = color_property, popup = content2) %>%
  addLegend(position = "topleft", pal = pal, values = ~q1_data$PROPERTY_USE, title = "Property Use") %>%
  setView(-74, 40.755, zoom = 1)

q2_a

```


__b) Cluster__
Add marker clustering, so that zooming in will reveal the individual locations but the zoomed out map only shows the clusters. Show the map with clusters.

```{r}
q2_b <- q2_a %>%
    setView(-74, 40.755, zoom = 12) %>%
  addCircleMarkers(clusterOptions = markerClusterOptions())

q2_b
```






### __3. Fire Houses__
The second data file contains the locations of the 218 firehouses in New York City. Start with the non-clustered map (2a) and now adjust the size of the circle markers by severity (`TOTAL_INCIDENT_DURATION` or `UNITS_ONSCENE` seem plausible options). More severe incidents should have larger circles on the map. On the map, also add the locations of the fire houses. Add two layers (“Incidents”, “Firehouses”) that allow the user to select which information to show.

```{r}
q3_a <- q1_m %>%
  addCircles(color = color_property, radius = ~UNITS_ONSCENE*5, popup = content2) %>% # add the radius by UNITS_ONSCENE
  addLegend(position = "topleft", pal = pal, values = ~q1_data$PROPERTY_USE, title = "Property Use") %>%
  setView(-74, 40.755, zoom = 11)

q3_a
```


```{r}
# Create leaflet map object with layers
q3_b <- leaflet(q1_data) %>%
  setView(-74, 40.755, zoom = 12) %>%
  # Background layer
  addTiles('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', group = "base") %>%
  # Data layer
  ## Layer 1: Incidents
  addCircles(lat = ~lat, lng = ~lon, group = "Incidents",
             color = color_property, radius = ~UNITS_ONSCENE*5, popup = content2) %>%
  addLegend(group = "Incidents", position = "topleft", pal = pal, values = ~q1_data$PROPERTY_USE, title = "Property Use") %>%
  ## Layer 2: Firehouses
  addCircles(lng = ~Longitude, lat = ~Latitude, group = "Firehouses",
              data = FDNY_fh_listing, radius = 5,
              color = "red", weight = 2.5, popup = paste("Facility Name: ", FDNY_fh_listing$FacilityName, "<br/>",
                                                         "Area in Charge: ", FDNY_fh_listing$NTA, "<br/>")) %>%
  # Layers control
  addLayersControl(baseGroups = c("Stadia"),
                   overlayGroups = c("Incidents", "Firehouses"),
                   options = layersControlOptions(collapsed = TRUE))

q3_b
```


### __4. Distance from Firehouse and Response Time__
We now want to investigate whether the distance of the incident from the nearest firehouse varies across the city.

__a) Calculate Distance__
For all incident locations (independent of severity), identify the nearest firehouse and calculate the distance between the firehouse and the incident location. Provide a scatter plot showing the time until the first engine arrived (the variables `INCIDENT_DATE_TIME` and `ARRIVAL_DATE_TIME`) will be helpful.


```{r}
# Calculate the distances, select the shortest length
# Add the closest firehouse facility name, latitute, longitute for each incident

## 1) Calculate distances
# Load library
library(geosphere)

# Matrix of firehouse locations
firehouses_loc <- FDNY_fh_listing %>% select(Longitude, Latitude) %>% as.matrix()

# Matrix of fire incident locations
fires_loc <- building_fires %>% select(lon, lat) %>% as.matrix()

# Copy building_fires dataframe, add new columns to store new information
fire_firehouses <- building_fires %>%
  mutate(closest_facility_name = 'Name',
  facility_latitude = 'latitude',
  facility_longitude = 'longitude',
  distance = 'dist')

# For loop to calculate distance and add the information to dataframe
for (i in 1:nrow(fire_firehouses)){
  k <- distm(fires_loc[i, ], firehouses_loc, fun = distGeo) == min(distm(fires_loc[i, ], firehouses_loc, fun = distGeo))
  v <- which(k, arr.ind = TRUE)[2] # Returns row number of closest facility

  # Add the information in the dataframe
  fire_firehouses$closest_facility_name[i] <- FDNY_fh_listing$FacilityName[v] #facility Name
  fire_firehouses$facility_latitude[i] <- FDNY_fh_listing$Latitude[v] # facility latitude
  fire_firehouses$facility_longitude[i] <- FDNY_fh_listing$Longitude[v] # facility longitude
  fire_firehouses$distance[i] <- min(distm(fires_loc[i, ], firehouses_loc, fun = distGeo)) # distance
}
```

```{r, message=FALSE}
# 2) Calculate time to arrival
library(lubridate)
library(stringr)

# Change `INCIDENT_DATE_TIME` and `ARRIVAL_DATE_TIME` to POSIXct time objects
fire_firehouses <- fire_firehouses %>%
  mutate(INCIDENT_DATE_TIME2 = as.POSIXct(INCIDENT_DATE_TIME, format = "%m/%d/%Y %I:%M:%S %p")) %>%
  mutate(ARRIVAL_DATE_TIME2 = as.POSIXct(ARRIVAL_DATE_TIME, format = "%m/%d/%Y %I:%M:%S %p"))

# Calculate the time difference
fire_firehouses <- fire_firehouses %>%
  mutate(time_diff_sec = difftime(ARRIVAL_DATE_TIME2, INCIDENT_DATE_TIME2, units = "secs"))

# Check
head(fire_firehouses)
```


```{r}
# Before plotting, make sure that distance and time_diff_sec are in numbers
fire_firehouses$time_diff_sec <- str_extract(fire_firehouses$time_diff_sec, '[0-9]*')

fire_firehouses <- fire_firehouses %>%
  mutate(distance = as.numeric(distance)) %>%
  mutate(time_diff_sec = as.numeric(time_diff_sec))

head(fire_firehouses)
```

```{r}
# Check if the values are correct (all bigger than zero etc.)
summary(fire_firehouses$time_diff_sec)
```

```{r}
# Check NA values
fire_firehouses %>%
  select(INCIDENT_DATE_TIME, ARRIVAL_DATE_TIME,
         INCIDENT_DATE_TIME2, ARRIVAL_DATE_TIME2, time_diff_sec) %>%
  filter(is.na(time_diff_sec))
```

The NA values in `time_diff_sec` variable are there because i) there is no record for `ARRIVAL_DATE_TIME` or ii) `ARRIVAL_DATE_TIME` is earlier than `INCIDENT_DATE_TIME`. The NA values are not because of computational error, so these are valid NA values, which will be excluded in the plotting below.


```{r}
# Create a scatter plot of distance and time_diff_sec

# check for outliers
summary(fire_firehouses$distance) # x axis
summary(fire_firehouses$time_diff_sec) # y axis
```

```{r}
# outlier values
dist_outlier <- quantile(fire_firehouses$distance, probs = (0.995), na.rm = TRUE)
time_diff_outlier <- quantile(fire_firehouses$time_diff_sec, probs = (0.995), na.rm = TRUE)
```

```{r}
# Create a scatter plot of distance and time_diff_sec
viz1 <- ggplot(data = fire_firehouses) +
  geom_point(aes(x = distance, y = time_diff_sec), alpha = 0.1) +
  xlim(0, dist_outlier) + # outliers out
  ylim(0, time_diff_outlier) + # outliers out
  geom_smooth(aes(x = distance, y = time_diff_sec), color = "red") +
  theme_minimal() +
  labs(title = "Distance from Firehouse and Time to Arrival",
       x = "Distance Between Fire and Nearest Firehouse (meters)",
       y = "Time to Arrival (seconds)") +
  theme(legend.position = "none")

viz1
```

```{r}
# Same x and y, but express density
viz2 <- ggplot(data = fire_firehouses) +
  geom_hex(aes(x = distance, y = time_diff_sec, bins = 100)) +
  xlim(0, dist_outlier) + # outliers out
  ylim(0, time_diff_outlier) + # outliers out
  labs(title = "Distance from Firehouse and Time to Arrival",
       x = "Distance Between Fire and Nearest Firehouse (meters)",
       y = "Time to Arrival (seconds)") +
  theme_minimal() +
  theme(legend.position = "none")

viz2
```

* __Analysis__

Visualization reveals a few important insights: first, the further the distance is, the longer it takes (as shown in the first visualization and regression line drawn). Second, the distance between fire incident and nearest firehouse is within 2 kilometers. Third, most cases are concentrated between under 1 km away from fire incident, and response time of 100 ~ 300 seconds range, which is approximately between 1.5 ~ 5 minutes.


Now also visualize the patterns separately for severe and non-severe incidents (use `HIGHEST_LEVEL_DESC` but feel free to reduce the number of categories). What do you find?
```{r}
fire_firehouses$HIGHEST_LEVEL_DESC2 <- str_extract(fire_firehouses$HIGHEST_LEVEL_DESC, "[0-9]")

fire_firehouses <- fire_firehouses %>%
  mutate(HIGHEST_LEVEL_DESC2 = ifelse(fire_firehouses$HIGHEST_LEVEL_DESC2 == 7, 1, fire_firehouses$HIGHEST_LEVEL_DESC2)) %>%
  mutate(HIGHEST_LEVEL_DESC2 = as.numeric(HIGHEST_LEVEL_DESC2)) %>%
  mutate(HIGHEST_LEVEL_DESC2 = HIGHEST_LEVEL_DESC2 + 1) %>%
  mutate(HIGHEST_LEVEL_DESC3 = factor(HIGHEST_LEVEL_DESC2, levels = c(1:6),
                                              labels = c("Initial Alarm",
                                                         "Mild",
                                                         "2nd Alarm",
                                                         "3rd Alarm",
                                                         "4th Alarm",
                                                         "5th Alarm")))
```


```{r, fig.width = 20, fig.height=10}
density_plot <- fire_firehouses %>%
  filter(!is.na(time_diff_sec)) %>% # filter out NA values
  ggplot(data = .) +
  geom_density_2d(aes(x = distance, y = time_diff_sec)) +
  xlim(0, dist_outlier) +
  ylim(0, time_diff_outlier) +
  facet_grid(cols = vars(HIGHEST_LEVEL_DESC3)) +
  theme_minimal() +
  labs(title = "Response Time and Distance by Fire Severity, Density Plot",
       x = "Distance Between Fire and Nearest Firehouse (meters)",
       y = "Time to Arrival (seconds)")

density_plot
```

* __Analysis__

Density plot shows that regardless of fire severity, the response time to fire and its relationship with the distance is similar.

```{r, fig.height= 6, fig.width= 8}
# Merge categories
library(stringr)

# Based on the number(hundredth values), of `PROPERTY_USE_DESC`, merge groups and rename the values

# Extract the first number of `PROPERTY_USE_DESC`
fire_firehouses$PROPERTY_USE_DESC2 <- str_sub(fire_firehouses$PROPERTY_USE_DESC, 1, 1)
fire_firehouses$PROPERTY_USE_DESC2 <- as.numeric(fire_firehouses$PROPERTY_USE_DESC2)


# Label each value by changing `PROPERTY_USE_DESC` as factor
fire_firehouses$PROPERTY_USE_DESC2 <- factor(fire_firehouses$PROPERTY_USE_DESC2, levels = c(0:9),
                                             labels = c("Other", "Store, Restaurant, Parking lot",
                                                        "Educational facility", "Healthcare facility",
                                                        "Residential facilty", "Businesses & Offices",
                                                        "Utility facility", "Factory", "Warehouses/storage",
                                                        "Street & Open land"), exclude = NULL)

vplot_boxplot <- fire_firehouses%>%
  filter(!is.na(PROPERTY_USE_DESC2), !is.na(time_diff_sec)) %>%
  filter(time_diff_sec < time_diff_outlier) %>%
  ggplot(.)+
  theme_minimal() +
  geom_violin(aes(x = PROPERTY_USE_DESC2, y = time_diff_sec), fill = "#dad1ff") +
  labs(title = "Response Time Distribution by Property Type",
       x = "Property Type",
       y = "Response Time",
       caption = "
       Note: Response time beyond the 99th percentile are excluded for visualization") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1)) +
  geom_boxplot(aes(x = PROPERTY_USE_DESC2, y = time_diff_sec), width = 0.4, alpha = 0.5)

vplot_boxplot
```

* __Analysis__

Violin plot with box plot shows that response time distribution varies by property type. Residential facilites and office spaces have response times densely clustered around the median response time, where as utility facility, healthcare facility, and open spaces (streets) have response times spread around.


__b) Map of Response Times__
Provide a map visualization of response times. Investigate whether the type of property affected (`PROPERTY_USE_DESC`) or fire severity (`HIGHEST_LEVEL_DESC`) play a role here.

```{r}
# Add colors
pal = colorFactor("Paired", domain = fire_firehouses$PROPERTY_USE_DESC2)
color_detector = pal(fire_firehouses$PROPERTY_USE_DESC2)


content3 <- paste("Fire Started: ", fire_firehouses$INCIDENT_DATE_TIME, "<br/>",
                 "Property Type: ", fire_firehouses$PROPERTY_USE_DESC2, "<br/>",
                 "Severity: ", fire_firehouses$HIGHEST_LEVEL_DESC3, "<br/>",
                 "Response Time: ", fire_firehouses$time_diff_sec)

fire_firehouses_ <- fire_firehouses %>% filter(!is.na(PROPERTY_USE_DESC2), !is.na(HIGHEST_LEVEL_DESC3))

# Create leaflet map object with layers
leaflet(fire_firehouses_) %>%
  setView(-74, 40.755, zoom = 12) %>%
  # Background layer
  addTiles('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png') %>%
  # Data layer
  ## Layer 1: Incidents
  addCircles(lat = ~lat, lng = ~lon,
             color = color_detector,
             radius = ~ (time_diff_sec - 100) * 0.5, popup = content3) %>%
  addLegend(pal = pal, group = "Property Use", position = "topleft", values = ~fire_firehouses_$PROPERTY_USE_DESC2, title = "Property Use")
```

* __Analysis__

The map shows that most often fire cases are fires at residential facilities. Stores, restaurants, parking lots have smaller radius, which means that the time to arrival is shorter.

Show a faceted choropleth map indicating how response times have developed over the years. What do you find?
```{r}
## Edit data so that there is i) borough, ii) year, iii) mean response time

# Add borough
fire_firehouses$BOROUGH <-str_extract(fire_firehouses$BOROUGH_DESC, "[A-z]+ [A-z]+|[A-z]+")

# Add year
fire_firehouses<- fire_firehouses %>%
  mutate(YEAR = lubridate::year(INCIDENT_DATE_TIME2))

# Add mean response time by borough and year, save it to a new dataframe
q4_d <- fire_firehouses %>%
  filter(!is.na(BOROUGH), !is.na(YEAR), !is.na(time_diff_sec)) %>%
  group_by(YEAR, BOROUGH) %>%
  summarise(response_time = mean(time_diff_sec, na.rm = TRUE)) %>%
  mutate(response_time = round(response_time, digits = 2)) %>%
  filter(!is.na(response_time)) %>%
  tidyr::spread(key = YEAR, value = response_time)
```

```{r}
# Merge it with geojson file
borough <- rgdal::readOGR("borough_boundaries.geojson")
borough@data <- left_join(borough@data, q4_d, by = c("boro_name" = "BOROUGH"))
```

```{r, fig.width=8, fig.height=6}
library(tmap)
time_by_year <- tm_shape(borough) +
  tm_layout(legend.position = c("left", "top")) +
  tm_borders(alpha = 0.4)+
  tm_polygons(c("2013", "2014", "2015", "2016", "2017", "2018"),
              style = "pretty",
              palette = "Blues",
              title = c("2013", "2014", "2015", "2016", "2017", "2018")) +
  tm_text("boro_name", col = "black", size = 1, shadow = FALSE, bg.color = "white", bg.alpha = 0.5)

time_by_year
```

* __Analysis__ :

The Choropleth map shows that on average, Brooklyn has the shortest time to arrival in all years. On average, Manhattan is improving, decreasing the time to arrival.
